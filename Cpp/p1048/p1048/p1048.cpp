#include <iostream>
/*辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。
为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。
医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药
，采每一株都需要一些时间，每一株也有它自身的价值。
我会给你一段时间，在这段时间里，你可以采到一些草药。
如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”

如果你是辰辰，你能完成这个任务吗？*/
using namespace std;//观察到题目中含有「时间」与「价值」字样，考虑使用 背包 求解

int a[1000][2], dp[1000][1000];
int main() {
	int n,t;//n为草药数目，t为总共用来采药时间
	cin >>t>> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i][0] >> a[i][1];//先时间，后价值
	}

	/*dp[i][j]表示在前i个草药花费j个时间（重量）能够获取的最大价值，抽象时间为重量
	* 用v[i]表示物品价值，w[i]表示物品重量
物品编号：1   2   3
物品重量：5   6   4
物品价值：20 10 12
那么 i=1 的时候，放入的是物品 1 ，这时候肯定是最优的啦！
那考虑一下 j，j 是当前容量，如果 j<5，那么是不是就不能放，dp[1][j](j<5)=0；那如果 j>5，就可以放了，dp[1][j](j>=5)=20；
接着 i=2 放两个物品，求的就是 dp[2][j] 了，当 j<5 的时候，是不是同样的 dp[2][j](j<5) 等于0；那当 j<6 是不是还是放不下第二个，只能放第一个；
故此时有：j<w[i]时，dp[i][j] = dp[i-1][j]
然后 dp[2][j](j>6)=20，是从前一个状态来的（注意这里就可以分为两种情况了）：一种是选择第二个物品放入dp[i-1][j-w[i]]+v[i]，另一种还是选择前面的物品dp[i-1][j]；
这里第二个物品放入  会有一个-w[i]的操作，是为了减去第二个物品的重量

*/

	for (int i = 1; i <= n; i++) {
		for (int j = t; j >=0; j--) {
			if (j < a[i][0]) {//假设的重量小于物体重量
				dp[i][j] = dp[i-1][j];//就应该为上一个状态的值
			}
			else {
				dp[i][j] = max(dp[i - 1][j - a[i][0]] + a[i][1], dp[i-1][j]);//考虑取第一个还是第二个
			}
		}
	}
	cout << dp[n][t];
}